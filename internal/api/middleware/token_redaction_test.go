package middleware_test

import (
	"context"
	"log/slog"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"github.com/google/uuid"
	"github.com/phrazzld/scry-api/internal/api/middleware"
	"github.com/phrazzld/scry-api/internal/service/auth"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// Token redaction specific mock
type TokenRedactionMockJWTService struct {
	mock.Mock
}

func (m *TokenRedactionMockJWTService) GenerateToken(ctx context.Context, userID uuid.UUID) (string, error) {
	args := m.Called(ctx, userID)
	return args.String(0), args.Error(1)
}

func (m *TokenRedactionMockJWTService) GenerateRefreshToken(ctx context.Context, userID uuid.UUID) (string, error) {
	args := m.Called(ctx, userID)
	return args.String(0), args.Error(1)
}

func (m *TokenRedactionMockJWTService) ValidateToken(ctx context.Context, token string) (*auth.Claims, error) {
	// We don't need to log anything here - the test should check if the token
	// appears in logs generated by the middleware, not by our test code
	return nil, auth.ErrInvalidToken
}

func (m *TokenRedactionMockJWTService) ValidateRefreshToken(ctx context.Context, token string) (*auth.Claims, error) {
	args := m.Called(ctx, token)
	var claims *auth.Claims
	if arg := args.Get(0); arg != nil {
		claims = arg.(*auth.Claims)
	}
	return claims, args.Error(1)
}

// TestTokenRedaction verifies that token values are properly redacted in logs
func TestTokenRedaction(t *testing.T) {
	// Setup log capture
	var logBuf strings.Builder
	handlerOpts := &slog.HandlerOptions{
		Level: slog.LevelDebug, // Enable all log levels
	}
	logger := slog.New(slog.NewTextHandler(&logBuf, handlerOpts))
	oldLogger := slog.Default()
	slog.SetDefault(logger)
	defer func() {
		slog.SetDefault(oldLogger)
	}()

	// Create a mock JWT service
	mockJWTService := new(TokenRedactionMockJWTService)

	// Create the middleware
	authMiddleware := middleware.NewAuthMiddleware(mockJWTService)

	// Create a test handler that just returns 200 OK
	nextHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})

	// Wrap the test handler with our middleware
	handler := authMiddleware.Authenticate(nextHandler)

	// Create a test request with an Authorization header containing a token
	req := httptest.NewRequest("GET", "/test", nil)
	req.Header.Set(
		"Authorization",
		"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
	)

	// Create a recorder to capture the response
	recorder := httptest.NewRecorder()

	// Process the request
	handler.ServeHTTP(recorder, req)

	// Get logs
	logs := logBuf.String()

	// Verify sensitive information is not in the logs
	assert.NotContains(t, logs, "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9", "Logs should not contain JWT tokens")
}
