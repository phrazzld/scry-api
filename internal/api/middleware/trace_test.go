package middleware_test

import (
	"bytes"
	"context"
	"encoding/json"
	"log/slog"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"github.com/go-chi/chi/v5"
	"github.com/phrazzld/scry-api/internal/api/middleware"
	"github.com/phrazzld/scry-api/internal/api/shared"
	"github.com/phrazzld/scry-api/internal/platform/logger"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestTraceMiddleware(t *testing.T) {
	// Set up a test handler that logs with context
	testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Get logger from context
		log := logger.FromContextOrDefault(r.Context(), slog.Default())

		// Log a test message with context
		log.Info("test handler executed")

		// Get trace ID and include in response
		traceID := shared.GetTraceID(r.Context())
		w.Header().Set("X-Trace-ID", traceID)
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("OK"))
	})

	// Create a buffer to capture log output
	var logBuf bytes.Buffer

	// Create a JSON handler that writes to our buffer
	handler := slog.NewJSONHandler(&logBuf, &slog.HandlerOptions{
		Level: slog.LevelDebug,
	})

	// Create a logger with the handler
	testLogger := slog.New(handler)

	// Create a new router with the trace middleware
	r := chi.NewRouter()
	r.Use(middleware.NewTraceMiddleware(testLogger))
	r.Get("/test", testHandler)

	// Create a test request
	req := httptest.NewRequest(http.MethodGet, "/test", nil)
	rr := httptest.NewRecorder()

	// Process the request
	r.ServeHTTP(rr, req)

	// Verify response
	assert.Equal(t, http.StatusOK, rr.Code, "Handler returned wrong status code")
	assert.Equal(t, "OK", rr.Body.String(), "Handler returned unexpected body")

	// Verify trace ID header was set
	traceIDHeader := rr.Header().Get("X-Trace-ID")
	assert.NotEmpty(t, traceIDHeader, "Trace ID header should be set")

	// Verify trace ID format (should be a 32-char hex string)
	assert.Len(t, traceIDHeader, 32, "Trace ID should be a 32-character hex string")

	// Parse the log entries (there should be at least two: one from middleware and one from handler)
	logEntries := strings.Split(strings.TrimSpace(logBuf.String()), "\n")
	assert.GreaterOrEqual(t, len(logEntries), 2, "Expected at least 2 log entries")

	// Verify both log entries contain the trace ID
	for i, entry := range logEntries {
		var logEntry map[string]interface{}
		err := json.Unmarshal([]byte(entry), &logEntry)
		require.NoError(t, err, "Failed to parse log entry %d", i)

		traceID, ok := logEntry["trace_id"].(string)
		assert.True(t, ok, "Log entry %d missing trace_id field", i)
		assert.Equal(t, traceIDHeader, traceID, "Trace ID in log entry %d doesn't match header", i)
	}
}

func TestTraceMiddlewareWithExistingTraceID(t *testing.T) {
	// Setup a test handler
	testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Get trace ID from context
		traceID := shared.GetTraceID(r.Context())
		w.Header().Set("X-Trace-ID", traceID)
		w.WriteHeader(http.StatusOK)
	})

	// Create a buffer to capture log output
	var logBuf bytes.Buffer

	// Create a JSON handler that writes to our buffer
	handler := slog.NewJSONHandler(&logBuf, &slog.HandlerOptions{
		Level: slog.LevelDebug,
	})

	// Create a logger with the handler
	testLogger := slog.New(handler)

	// Create a router with trace middleware
	r := chi.NewRouter()
	r.Use(middleware.NewTraceMiddleware(testLogger))
	r.Get("/test", testHandler)

	// Create a request with a pre-existing trace ID
	req := httptest.NewRequest(http.MethodGet, "/test", nil)
	existingTraceID := "existing-trace-id"

	// Add the existing trace ID to the context
	ctx := context.WithValue(req.Context(), shared.TraceIDKey, existingTraceID)
	req = req.WithContext(ctx)

	// Process the request
	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)

	// Verify the trace ID in the response header
	// The middleware should override the existing trace ID with a new one
	traceIDHeader := rr.Header().Get("X-Trace-ID")
	assert.NotEmpty(t, traceIDHeader, "Trace ID header should be set")
	assert.NotEqual(t, existingTraceID, traceIDHeader, "Trace ID should be regenerated by middleware")

	// Parse a log entry
	logEntries := strings.Split(strings.TrimSpace(logBuf.String()), "\n")
	assert.NotEmpty(t, logEntries, "Expected at least one log entry")

	var logEntry map[string]interface{}
	err := json.Unmarshal([]byte(logEntries[0]), &logEntry)
	require.NoError(t, err, "Failed to parse log entry")

	traceID, ok := logEntry["trace_id"].(string)
	assert.True(t, ok, "Log entry missing trace_id field")
	assert.Equal(t, traceIDHeader, traceID, "Trace ID in log doesn't match header")
}

func TestLoggerEnrichmentInContext(t *testing.T) {
	// Setup a test handler that logs with context
	testHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Get logger from context
		log := logger.FromContextOrDefault(r.Context(), slog.Default())

		// Log different messages to verify trace ID is included
		log.Debug("debug message")
		log.Info("info message")
		log.Warn("warning message")
		log.Error("error message")

		w.WriteHeader(http.StatusOK)
	})

	// Create a buffer to capture log output
	var logBuf bytes.Buffer

	// Create a JSON handler that writes to our buffer
	handler := slog.NewJSONHandler(&logBuf, &slog.HandlerOptions{
		Level: slog.LevelDebug,
	})

	// Create a logger with the handler
	testLogger := slog.New(handler)

	// Create a router with trace middleware
	r := chi.NewRouter()
	r.Use(middleware.NewTraceMiddleware(testLogger))
	r.Get("/test", testHandler)

	// Process the request
	req := httptest.NewRequest(http.MethodGet, "/test", nil)
	rr := httptest.NewRecorder()
	r.ServeHTTP(rr, req)

	// Parse all log entries
	logEntries := strings.Split(strings.TrimSpace(logBuf.String()), "\n")

	// Should have at least 5 log entries:
	// 1. "request started" from middleware
	// 2-5. Four log messages from the handler at different levels
	assert.GreaterOrEqual(t, len(logEntries), 5, "Expected at least 5 log entries")

	// Extract the trace ID from the first log entry
	var firstEntry map[string]interface{}
	err := json.Unmarshal([]byte(logEntries[0]), &firstEntry)
	require.NoError(t, err, "Failed to parse first log entry")

	traceID, ok := firstEntry["trace_id"].(string)
	assert.True(t, ok, "First log entry missing trace_id field")
	assert.NotEmpty(t, traceID, "Trace ID should not be empty")

	// Verify all subsequent log entries have the same trace ID
	for i := 1; i < len(logEntries); i++ {
		var entry map[string]interface{}
		err := json.Unmarshal([]byte(logEntries[i]), &entry)
		require.NoError(t, err, "Failed to parse log entry %d", i)

		entryTraceID, ok := entry["trace_id"].(string)
		assert.True(t, ok, "Log entry %d missing trace_id field", i)
		assert.Equal(t, traceID, entryTraceID, "Trace ID in log entry %d doesn't match first entry", i)
	}
}
